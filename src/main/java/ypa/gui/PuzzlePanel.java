package ypa.gui;

import ypa.model.YCell;
import ypa.model.YPuzzle;

import java.awt.*;
import java.awt.event.MouseEvent;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

/**
 * A graphical view on a Kakuro puzzle state.
 *
 * @author Tom Verhoeff (Eindhoven University of Technology)
 */
public class PuzzlePanel extends javax.swing.JPanel {

    /**
     * Creates new form PuzzlePanel.
     */
    public PuzzlePanel() {
        initComponents();
        initPanel();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    /** Cell size in pixels. */
    private final int cellSize = 60;
    // TODO: Consider making the cell size changeable by user

    final int offsetX = cellSize; // margin for horizontal coordinates
    final int offsetY = cellSize; // margin for vertical coordinates

    /** The puzzle being manipulated. */
    private YPuzzle puzzle;

    /** Selected cell, affected by keystrokes. */
    private YCell selected;

    /** Whether symbols are highlighted. */
    private boolean highlight;

    /** Whether clearing the previous violated cell is used or not. */
    private boolean clear;

    /** Marked cells (by different background color). */
    private Set<YCell> markedCells;

    /** Violated cells (by different background color). */
    private Set<YCell> violatedCells;    

    /** Clear previously violated cells. */
    private Set<YCell> clearViolatedCells; 

    /**
     * Initializes this panel.
     */
    private void initPanel() {
        setPuzzle(null);
        highlight = true;
        clear = false;
    }
    
    /**
     * Sets the puzzle.
     *
     * @param puzzle  the puzzle
     */
    public void setPuzzle(final YPuzzle puzzle) {
        this.puzzle = puzzle;
        this.selected = null;
        this.markedCells = null;
        this.violatedCells = new HashSet<>();
        this.clearViolatedCells = new HashSet<>();
    }

    /**
     * Gets selected cell.
     *
     * @return the selected cell
     */
    public YCell getSelected() {
        return selected;
    }

    /**
     * Sets selected cell.
     *
     * @param cell  the selected cell
     */
    public void setSelected(final YCell cell) {
        this.selected = cell;
    }

    /**
     * Sets whether to highlight the marked cells.
     *
     * @param newState  the new highlighting state
     */
    public void setHighlight(final boolean newState) {
        this.highlight = newState;
    }

    /**
     * Sets the marked cells, which will be highlighted if enabled.
     *
     * @param markedCells  the cells to mark, or {@code null} if none
     */
    public void setMarkedCells(final Collection<YCell> markedCells) {
        if (markedCells == null) {
            this.markedCells = new HashSet<>();
        } else {
            this.markedCells = new HashSet<>(markedCells);
        }
    }

    /**
     * Sets the violated cells to red.
     *
     * @param violatedCells  the cells to mark, or {@code null} if none
     */
    public void setViolatedCells(final Collection<YCell> violatedCells) {
        if (violatedCells == null) {
            this.violatedCells = new HashSet<>();
        } else {
            this.violatedCells = new HashSet<>(violatedCells);
            clear = false;
        }
    }    

    /**
     * Sets the violated cells to red.
     *
     * @param clearViolatedCells  the cells to mark, or {@code null} if none
     */
    public void clearViolatedCells(final Collection<YCell> clearViolatedCells) {
        if (clearViolatedCells == null) {
            this.clearViolatedCells = new HashSet<>();
            clear = false;
        } else {
            this.clearViolatedCells = new HashSet<>(clearViolatedCells);
            clear = true;

        }
    }     
    /**
    /**
     * Draws given cell on given canvas at given location.
     *
     * @param g  Graphics object to draw on
     * @param cell  cell to draw
     * @param x  x-coordinate for bottom left corner of cell
     * @param y  y-coordinate for bottom left corner of cell
     * @param delta_x  x-offset for digit within cell
     * @param delta_y  y-offset for digit within cell
     */
    private void paintCell(final Graphics g, final YCell cell,
            final int x, final int y, final int delta_x, final int delta_y) {

        if (clear && this.clearViolatedCells.contains(cell)) {
            g.setColor(Color.BLACK);
            g.drawString(cell.toString(), x + delta_x, y - delta_y);
            
        }
        if (!clear && this.violatedCells.contains(cell)) {
            g.setColor(Color.RED);
            g.fillRect(x + 1, y - cellSize + 1,
                    cellSize - 1, cellSize - 1);
        }
        // set background if cell is marked
        if (highlight && this.markedCells != null
                && this.markedCells.contains(cell)) {
            g.setColor(Color.CYAN);
            g.fillRect(x + 1, y - cellSize + 1,
                    cellSize - 1, cellSize - 1);
        }
        if (selected != null && cell == selected) {
            g.setColor(Color.YELLOW);
            g.fillRect(x + 1, y - cellSize + 1,
                    cellSize - 1, cellSize - 1);
        }

        // draw cell content, if not empty
        if (! cell.isEmpty()) {
            // cell occupied by a symbol
            // set color for symbol
            Color color = Color.BLACK;
            if (highlight) {
                if (! cell.isValid()) {
                    color = Color.RED;
                } else if (puzzle.isSolved()) {
                    color = Color.GREEN;
                }
            }
            g.setColor(color);

            g.drawString(cell.toString(), x + delta_x, y - delta_y);
        }
    }

    /**
    /**
     * Draws given sujiko circle containing the inputs the canvas at given location.
     *
     * @param g  Graphics object to draw on
     * @param cell  cell to draw
     */
    private void paintCircle(Graphics g) {
        FontMetrics fm = g.getFontMetrics();
        final int delta_x = ((int) (0.5 * cellSize) - fm.charWidth('0')) / 2 + 1;
        final int delta_y = ((int) (1.4 * cellSize) - fm.getAscent() + fm.getDescent()) / 2;
        int[] circles = puzzle.getCircles();
        int index = 0;
    
        // Constants for circle dimensions and offsets
        // 18 = 3 / 5 cellSize, 6 = 1 / 5 cellSize
        // Offset x, y by 0.6 cellSize, dimensions by 0.2 cellSize
        final int circleOffset = (int) (0.6 * cellSize);
        final int circleDiameter = cellSize - (int) (0.2 * cellSize);
        final int circleOffsetAdjustment = 1;
    
        for (int i = 1; i <= 2; i++) {
            for (int j = 1; j <= 2; j++) {
                int x = j * cellSize + circleOffset;
                int y = i * cellSize + circleOffset;
    
                drawFilledCircle(g, x, y, circleDiameter, circleOffsetAdjustment);
                drawCircleBorder(g, x, y, circleDiameter);
                drawCircleNumber(g, x, y, circles[index], delta_x, delta_y);
    
                index++;
            }
        }
    }
    
    private void drawFilledCircle(Graphics g, int x, int y, int diameter, int adjustment) {
        g.setColor(Color.WHITE);
        g.fillOval(x + adjustment, y + adjustment, diameter - adjustment, diameter - adjustment);
    }
    
    private void drawCircleBorder(Graphics g, int x, int y, int diameter) {
        g.setColor(Color.BLACK);
        g.drawOval(x, y, diameter, diameter);
    }
    
    private void drawCircleNumber(Graphics g, int x, int y, int number, int delta_x, int delta_y) {
        g.setColor(Color.BLACK);
        g.drawString(String.valueOf(number), x + delta_x, y + delta_y);
    }
    

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        g.setColor(java.awt.Color.DARK_GRAY);
        g.fillRect(0, 0, this.getWidth(), this.getHeight());
        g.setFont(new Font("Lucida Sans Typewriter", Font.BOLD, 24));
        if (puzzle == null) {
            g.setColor(Color.YELLOW);
            g.drawString("No puzzle loaded", cellSize, cellSize);
            return;
        }
        // puzzle != null
        final int WIDTH = cellSize * puzzle.getColumnCount();
        final int HEIGHT = cellSize * puzzle.getRowCount();
        // WIDTH, HEIGHT includes top, left border for showing coordinates
        FontMetrics fm = g.getFontMetrics();
        final int delta_x = (cellSize - fm.charWidth('0')) / 2 + 1;
        final int delta_y = (cellSize - fm.getAscent() + fm.getDescent()) / 2;

        g.setColor(Color.WHITE);
        g.fillRect(cellSize, cellSize, WIDTH, HEIGHT);
        g.setColor(java.awt.Color.BLACK);
        // draw all horizontal separator lines
        for (int r = 0; r <= puzzle.getRowCount(); ++ r) {
            final int y = r * cellSize + offsetY;
            g.drawLine(offsetX, y, WIDTH + offsetX, y);
        }
        // draw all vertical separator lines
        for (int c = 0; c <= puzzle.getColumnCount(); ++ c) {
            final int x = c * cellSize + offsetX;
            g.drawLine(x, offsetY, x, HEIGHT + offsetY);
        }
        // draw cell background and contents
        for (int r = 0; r != puzzle.getRowCount(); ++ r) {
            final int y = (r + 1) * cellSize + offsetY;
            for (int c = 0; c != puzzle.getColumnCount(); ++ c) {
                final int x = c * cellSize + offsetX;
                // x, y = coordinate of bottom-left corner
                final YCell cell = puzzle.getCell(r, c);
                paintCell(g, cell, x, y, delta_x, delta_y);
            }
        }
        paintCircle(g);
        /*
        // draw entries sums
        g.setColor(Color.WHITE);
        g.setFont(new Font("Lucida Sans Typewriter", Font.PLAIN, 12));
        for (KEntry entry : puzzle.getEntries()) {
            final int row; // row index of cell to show sum of entry
            final int column; // column index of cell to show sum of entry
            final int x; // x-coordinate of bottom-left corner
            final int y; // y-coordinate of bottom-left corner
            final int dx; // x-offset for showing sum
            final int dy; // y-offset for showing sum
            switch (entry.getDirection()) {
                case HORIZONTAL -> {
                    row = entry.getLocation().getRow();
                    column = entry.getLocation().getColumn() - 1;
                    dx = cellSize / 2 + 1;
                    dy = cellSize / 2 + 1;
                }
                case VERTICAL -> {
                    row = entry.getLocation().getRow() - 1;
                    column = entry.getLocation().getColumn();
                    dx = cellSize / 8 + 1;
                    dy = cellSize / 8 - 1;
                }
                default -> throw new IllegalStateException(getClass().getSimpleName()
                        + ".paintComponent(): bad direction");
            }
            x = column * cellSize + offsetX;
            y = (row + 1) * cellSize + offsetY;
            // draw sum, in smaller font
            final int sum = entry.getSpecification().getSum();
            g.drawString(String.format("%2d", sum), x + dx, y - dy);
        }*/
    }

    /**
     * Returns cell in grid for a given mouse event.
     *
     * @param evt  the mouse event
     * @return  cell in grid at {@code evt}, or {@code null} if non-existent
     * @pre {@code evt != null}
     */
    public YCell mouseToCell(final MouseEvent evt) {
        if (puzzle == null) {
            return null;
        }
        final int row = (evt.getY() - offsetY) / cellSize;
        final int col = (evt.getX() - offsetX) / cellSize;
        
        /*
        if (puzzle.has(row, col)) {
            return puzzle.getCell(row, col);
        } else {
            return null;
        }*/
        return puzzle.getCell(row, col);
    }

}
